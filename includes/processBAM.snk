rule index_bam:
    input:
        "{folder}/{sample}_{type}.{chrom_split}.bam"
    output:
        "{folder}/{sample}_{type}.{chrom_split}.bai"
    threads:
        config['bamindex']['threads']
    conda:
        "../env/align-env.yml"
    shell:
        "picard BuildBamIndex INPUT={input}"


rule tag_bam_with_umi:
    input:
        "mapped/{sample}_{type}.{split}.bam",
        "fastq/{sample}_{type}_index.{split}.fastq.gz"
    output:
        "umi/{sample}_{type}.{split}.bam",
        "umi/{sample}_{type}.{split}.bai"
    conda:
        "../env/fgbio-env.yml"
    threads:
        math.ceil(int(config['tag_bam']['max_mem'].strip('g')) / 2)
    params:
        max_mem = config['tag_bam']['max_mem']
    shell:
        "fgbio AnnotateBamWithUmis -Xms500m -Xmx{params.max_mem} -i {input[0]} -f {input[1]} -o {output[0]}"



rule merge_bam:
    '''
    here the split and umified bams are merged
    depending on input required by recalib, this can be umi/X-Y.bam or mapped
    '''

    input: # here I need a switch if no UMI is involved
        expand("{folder}/{{sample}}_{{type}}.{split}.bam", split=list(range(config['fastq']['split_factor'])), folder="umi" if config['tag_bam']['run'] else "mapped")
    output:
        "bam_merge/{sample}_{type}.bam"
    threads:
        config['resplit_bam']['threads']
    params:
        folder = "umi" if config['tag_bam']['run'] else "mapped"
    conda:
        "../env/align-env.yml"
    shell:
        # merge all split bams into one bam using samtools merge (also sorts the merged bam)
        "samtools merge {output[0]} {params.folder}/{wildcards.sample}_{wildcards.type}.*.bam; "
        "picard BuildBamIndex INPUT={output}"


rule resplit_bam:
    '''
    chromosome-split merged bams into chromosome-split bams (one split per job) with index
    '''

    input:
        "bam_merge/{sample}_{type}.bam"
    output:
        "bam_merge/{sample}_{type}.{chrom}.bam"
    threads:
        config['resplit_bam']['threads']
    conda:
        "../env/align-env.yml"
    shell:
        "samtools view -hb {input} {wildcards.chrom} > {output}; "
        "picard BuildBamIndex INPUT={output}"


rule dedup:
    input:
        "bam_merge/{sample}_{type}.{chrom}.bam"
    output:
        "deduped/{sample}_{type}.{chrom}.bam"
    log:
        "logs/dedup/{sample}_{type}.{chrom}.log"
    params:
        metric = lambda w: f"deduped/{w.sample}_{w.type}.{w.chrom}.metric.txt"
    threads:
        config['dedup']['threads']
    conda:
        "../env/align-env.yml"
    shell:
        "picard MarkDuplicates I={input} O={output} M={params.metric} REMOVE_DUPLICATES=true &>{log}"


rule dedup_umi:
    input:
        "bam_merge/{sample}_{type}.{chrom}.bam"
    output:
        "umi_deduped/{sample}_{type}.{chrom}.bam"
    params:
        metric = lambda w: f"umi_deduped/{w.sample}_{w.type}.{w.chrom}.metric.txt",
        umi_metrics = lambda w: f"umi_deduped/{w.sample}_{w.type}.{w.chrom}.umi_metric.txt",
        max_mem = config['dedup_umi']['max_mem'],
        remove_dups = "false" if config['dedup_umi']['keep_dups'] else "true"
    threads:
        int(config['dedup_umi']['max_mem'].strip('g'))
    log:
        "logs/dedup/{sample}_{type}.{chrom}.log"
    conda:
        "../env/align-env.yml"
    shell:
        "picard UmiAwareMarkDuplicatesWithMateCigar -Xms500m -Xmx{params.max_mem} UMI_METRICS={params.umi_metrics} I={input} O={output[0]} M={params.metric} ASSUME_SORTED=true REMOVE_DUPLICATES={params.remove_dups}; " # &>{log}


def realign_ref():
    '''
    returns ref parameters for realign-refs gatk tools
    '''

    return f"-R {full_path('genome')} -known {full_path('gold_standard_indels')} -known {full_path('phase1k_indels')}"


def ir_params(_, input, output):
    '''
    params for realignGATK
    '''

    return f"{realign_ref()} -targetIntervals {input.intervals} -I {input.bam} -o {output}"


rule create_GATK_target_list:
    # the target has to be created only once and can be stored at the original REF position
    output:
        "realigned/GATK_targets.intervals"
    threads:
        config['realignGATK']['threads']
    log:
        "logs/realign/targetList"
    conda:
        "../env/gatk3-env.yml"
    params:
        gatk = config['tools']['gatk3'],
        realign = lambda _, output: f"{realign_ref()} -nt {config['realignGATK']['threads']} -o {output}"
    shell:
        "{params.gatk} RealignerTargetCreator {params.realign} &>{log}"


rule realignGATK:
    input:
        bam = lambda w: f"umi_deduped/{w.sample}_{w.type}.{w.chrom}.bam" if config['tag_bam']['run'] else f"deduped/{w.sample}_{w.type}.{w.chrom}.bam",
        bai = lambda w: f"umi_deduped/{w.sample}_{w.type}.{w.chrom}.bai" if config['tag_bam']['run'] else f"deduped/{w.sample}_{w.type}.{w.chrom}.bai",
        intervals = "realigned/GATK_targets.intervals"
    output:
        "realigned/{sample}_{type}.{chrom}.bam"
    log:
        "logs/realign/{sample}_{type}.{chrom}.log"
    threads:
        config['realignGATK']['threads']
    conda:
        "../env/gatk3-env.yml"
    params:
        gatk = config['tools']['gatk3'],
        ir = ir_params
    shell:
        "{params.gatk} IndelRealigner {params.ir} &>{log}"


rule base_recalibrator:
    input:
        bam = "realigned/{sample}_{type}.{chrom}.bam",
        bai = "realigned/{sample}_{type}.{chrom}.bai"
    output:
        bam = "recalib/{sample}_{type}.{chrom}.bam",
        table = "recalib/{sample}_{type}.{chrom}.recal_table"
    log:
        "logs/recalib/{sample}_{type}.{chrom}.log"
    params:
        gatk = config['tools']['gatk'],
        genome = f"-R {full_path('genome')}",
        known_sites = f"--known-sites {full_path('gold_standard_indels')} --known-sites {full_path('phase1k_indels')} --known-sites {full_path(config['recalib']['known_sites'])}",
        apply_table = lambda w, input, output: f"--bqsr-recal-file recalib/{w.sample}_{w.type}.recal_table -O {output}"
    threads:
        config['recalib']['threads']
    conda:
        "../env/gatk4-env.yml"
    shell:
        "{params.gatk} BaseRecalibrator -I {input.bam} {params.genome} {params.known_sites} -O {output.table} &>{log}; " #  
        # apply recalibration table on input
        "{params.gatk} ApplyBQSR -I {input.bam} {params.genome} --bqsr-recal-file {output.table} -O {output.bam} &>>{log}; " # 
        # recreate recalibration table from output for QC
        "{params.gatk} BaseRecalibrator -I {output.bam} {params.genome} {params.known_sites} -O {output.table} &>>{log}"  #  


rule cover_BED:
    input:
        sample = "bam_merge/{sample}_{type}.bam",
        ref_gen = os.path.join(full_path('genome_path'), 'gen_ref.done')
    output:
        "coverBED/{sample}_{type}.txt"
    log:
        "logs/coverBED/{sample}_{type}.log"
    threads: 2
    params:
        format_coverage = get_script('format_bed_coverage'),
        exon_cover = get_bed_file('Covered'),
        prettifyBed = get_script('prettifyBED'),
        fastq = get_fastq_pair,
        refgen = full_path('genome')
    conda:
        "../env/bedcover-env.yml"
    script:
        "../scripts/bedcover.py"

