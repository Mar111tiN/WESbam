rule get_fastq:
    input:
        get_fastqs  # looks up samples from file_list
    output:
        "fastq/{sample}_{type}_{read_or_index}.fastq.gz"
    threads: config['fastq']['threads']
    wildcard_constraints:
        sample = "[^/]+"
    run:
        extension = os.path.splitext(input[0])[1]

        if extension == '.fastq':
            # shell("ln -s {input} {output}")   # create shortcut to fastq in workdir/fastq
            shell("gzip {input} > {output}")
        elif extension == '.gz':
            # print(f"file extension {extension} --> unzipping with gunzip")
            # shell("gunzip -c {input} > {output}") # uncompress fastq.qz to fastq in workdir/fastq
            if config['fastq']['subsample_normal_factor'] > 1:
                print(output, output[0])
                if f"_{config['samples']['normal']}_" in output[0]:
                    lines = round(config['fastq']['subsample_normal_factor'] * 4)
                    print(f"Subsampling normal file {input}")
                    shell(f"gunzip < {{input}} | mawk 'NR % {lines} > 0 && NR % {lines} < 5' | gzip > {{output}}")
                else:
                    print(f"Creating a symlink for file {input}")
                    shell("ln -s {input} {output}")
            else:
                print(f"Creating symlink for file {input}")
                shell("ln -s {input} {output}")   # create shortcut to fastq.gz in workdir/fastq
        elif extension == '.bz2':
            print(f"file extension {extension} --> unzipping with bzcat")
            shell("bzcat {input} | gzip > {output}") # uncompress fastq.b2 and recompress to fastq.gz in workdir/fastq 


rule split_fastq:
    input:
        "fastq/{sample}_{type}_{read_or_index}.fastq.gz"
    output:
        expand("fastq/{{sample}}_{{type}}_{{read_or_index}}.{split}.fastq", split=list(range(config['fastq']['split_factor'])))
    threads: 1
    params:
        split_factor=config['fastq']['split_factor'],
        split_tool=get_script('split_fastq'),
        output_base=lambda w: f"fastq/{w.sample}_{w.type}_{w.read_or_index}"
    shell:
        "{params.split_tool} {input} {params.split_factor} {params.output_base}"



rule compress_split_fastq:
    input:
        "fastq/{sample}_{type}_{read}.{split}.fastq"
    output:
        "fastq/{sample}_{type}_{read}.{split}.fastq.gz"
    threads: 1
    shell:
        "gzip {input}"
 

def get_trim_params(w, input, output, threads):
    '''
    accessory for Trimmomatic
    retrieves settings from config file and translates into Trimmomatic call
    '''

    if config['trim']['program'] == 'trimmomatic':
        trim_mode = ' '.join(config['trim']['mode']) # concatenate trim mode options
        adapter_file = os.path.join(config['snakedir'], config['trim']['adapters'])
        trim_mode = trim_mode.replace('<adapter>', adapter_file)
        files = list(input)
        files += list(output)
        files = " ".join(files)
        return f"{files} {trim_mode}"



rule trim_fastq_PE:
    input: 
        expand("fastq/{{sample}}_{{type}}_{read}.{{split}}.fastq.gz", read=config['samples']['reads'])
    output: 
        expand("fastq_trimmed/{{sample}}_{{type}}_{read}.{{split}}.{trim}.fastq.gz", read=config['samples']['reads'], trim=config['trim']['suffix'])
    conda:
        "../env/trim-env.yml"
    threads:
        config["trim"]["threads"]
    log:
        "logs/trim/{sample}_{type}.{split}.log"
    params: 
        run = f"{config['setup']['run']} -phred{config['setup']['phred']}",
        files_n_mode = get_trim_params
    shell:
        "trimmomatic {params.run} -threads {threads} -trimlog {log} {params.files_n_mode}"
